PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n" |
        <"//" (~["\n", "\r"])* ("\n" | "\r")> |
        <"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">;

TOKEN :
    // arithmetic
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |

	// other symbols
	< DOT : "." > |
	< COMMA : "," > |
	< SEMICOLON : ";" > |
	< EQUALS : "=" > |
	< AND : "&&" > |
	< LT : "<" > |
	< OPEN_PAREN : "(" > |
    < CLOSE_PAREN : ")" > |
    < OPEN_CURL : "{" > |
    < CLOSE_CURL : "}" > |
    < OPEN_SQUARE : "[" > |
    < CLOSE_SQUARE : "]" > |

	// keywords
	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
    < STATIC : "static" > |
    < VOID : "void" > |
    < MAIN : "main" > |
    < STRING : "String" > |
	< RETURN : "return" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
    < LENGTH : "length" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < NOT : "!" > |
    < THIS : "this" > |
    < NEW : "new" > |

	// last possibilities
	< INTEGER : (["0" - "9"])+ > |
	< IDENT : ["A" - "Z","a" - "z","_"](["A" - "Z","a" - "z","_","0" - "9"])* >
;

Program : (ImportDeclaration)* ClassDeclaration <EOF> ;

ImportDeclaration : <IMPORT> Identifier (<DOT> Identifier)* <SEMICOLON> ;

ClassDeclaration : <CLASS> Identifier (<EXTENDS> Identifier)?
                   <OPEN_CURL> (VarDeclaration)* (<PUBLIC> MethodDeclaration)* <CLOSE_CURL> ;  // class declaration

VarDeclaration : SCAN 2 Type Identifier <SEMICOLON> ;

MethodDeclaration : <STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_SQUARE> <CLOSE_SQUARE> Identifier <CLOSE_PAREN>  // psvm
                    <OPEN_CURL> MethodContent <CLOSE_CURL> |
                    Type Identifier <OPEN_PAREN> ( Type Identifier ( <COMMA> Type Identifier )* )? <CLOSE_PAREN>
                    <OPEN_CURL> MethodContent
                    <RETURN> Expression <SEMICOLON> <CLOSE_CURL> ;                                                      // generic method declaration

MethodContent #void: (VarDeclaration)* (Statement)*;

Type #void: <INT> (<OPEN_SQUARE> <CLOSE_SQUARE>)? |  //spaghettios
       <BOOLEAN> |
       <STRING> |
       Identifier ;

Statement : <OPEN_CURL> (Statement)* <CLOSE_CURL> |
            <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement |  // if then else
            <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement |                // while loop
            SCAN 2 Assignment |
            Expression <SEMICOLON>;

Assignment : Identifier (Indexing)? <EQUALS> Expression <SEMICOLON> ;

Expression : AndExpression ;

Indexing #void: <OPEN_SQUARE> Expression <CLOSE_SQUARE> ;

AndExpression #void: CompareExpression (<AND> CompareExpression)* ;

CompareExpression #void: AdditiveExpression (<LT> AdditiveExpression)* ;

AdditiveExpression #void: MultiplicativeExpression ( (<PLUS> | <MINUS>) MultiplicativeExpression )* ;

MultiplicativeExpression #void: AccessExpression ( (<TIMES> | <DIVIDE>) AccessExpression )* ;

AccessExpression #void: Factor (Indexing | <DOT> CallExpression)? ;

CallExpression #void: <LENGTH> |
                 Identifier <OPEN_PAREN> (Expression (<COMMA> Expression)*)? <CLOSE_PAREN> ;  // method call

Factor #void: <INTEGER> | <TRUE> | <FALSE> | <THIS> |
        <NOT> Factor |
        <NEW> NewExpression |
        <OPEN_PAREN> AndExpression <CLOSE_PAREN> |
        Identifier ;

NewExpression #void: <INT> <OPEN_SQUARE> Expression <CLOSE_SQUARE> |  // create int array
                Identifier <OPEN_PAREN> <CLOSE_PAREN> ;          // Identifier constructor call

Identifier : <IDENT> ;
