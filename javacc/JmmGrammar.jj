PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : " " | "\t" | "\r" | "\n" |
        <"//" (~["\n", "\r"])* ("\n" | "\r")> |
        <"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">;

TOKEN :
    // arithmetic
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |

	// other symbols
	< DOT : "." > |
	< COMMA : "," > |
	< SEMICOLON : ";" > |
	< EQUALS : "=" > |
	< AND : "&&" > |
	< LT : "<" > |
	< OPEN_PAREN : "(" > |
    < CLOSE_PAREN : ")" > |
    < OPEN_CURL : "{" > |
    < CLOSE_CURL : "}" > |
    < OPEN_SQUARE : "[" > |
    < CLOSE_SQUARE : "]" > |

	// keywords
	< IMPORT : "import" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
    < STATIC : "static" > |
    < VOID : "void" > |
    < MAIN : "main" > |
    < STRING : "String" > |
	< RETURN : "return" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
    < LENGTH : "length" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < NOT : "!" > |
    < THIS : "this" > |
    < NEW : "new" > |

	// last possibilities
	< INTEGER : (["0" - "9"])+ > |
	< IDENT : ["A" - "Z","a" - "z","_"](["A" - "Z","a" - "z","_","0" - "9"])* >
;

Program : (ImportDeclaration)* ClassDeclaration <EOF> ;

ImportDeclaration : <IMPORT> Identifier (<DOT> Identifier)* <SEMICOLON> ;

ClassDeclaration : <CLASS> Identifier (<EXTENDS> Identifier)?
                   <OPEN_CURL> (VarDeclaration)* (<PUBLIC> MethodDeclaration)* <CLOSE_CURL> ;

VarDeclaration : SCAN 2 Type Identifier <SEMICOLON> ;

MethodDeclaration #void: MainMethod | RegularMethod;

MainMethod: <STATIC> <VOID> <MAIN> <OPEN_PAREN> StringArg <CLOSE_PAREN>
            <OPEN_CURL> MethodContent <CLOSE_CURL>;

RegularMethod: Type Identifier <OPEN_PAREN> (Args)? <CLOSE_PAREN>
               <OPEN_CURL> MethodContent
               <RETURN> Expression <SEMICOLON> <CLOSE_CURL> ;

StringArg: <STRING> <OPEN_SQUARE> <CLOSE_SQUARE> Identifier;

Args: Type Identifier ( <COMMA> Type Identifier )* ;

MethodContent #void: (VarDeclaration)* (Statement)*;

Type #void: <INT> (<OPEN_SQUARE> <CLOSE_SQUARE>)? |
            <BOOLEAN> |
            <STRING> |
            Identifier ;

Statement #void: ScopeStatement |
                 IfElseStatement |
                 WhileStatement |
                 SCAN 2 Assignment |
                 Expression <SEMICOLON>;

ScopeStatement: <OPEN_CURL> (Statement)* <CLOSE_CURL>;

IfElseStatement: <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement;

WhileStatement: <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement;

Assignment : Identifier (Indexing)? <EQUALS> Expression <SEMICOLON> ;

Indexing : <OPEN_SQUARE> Expression <CLOSE_SQUARE> ;

Expression #void: AndExpression ;

AndExpression #void: CompareExpression (<AND> CompareExpression)* ;

CompareExpression #void: AdditiveExpression (<LT> AdditiveExpression)* ;

AdditiveExpression #void: MultiplicativeExpression ( (<PLUS> | <MINUS>) MultiplicativeExpression )* ;

MultiplicativeExpression #void: AccessExpression ( (<TIMES> | <DIVIDE>) AccessExpression )* ;

AccessExpression #void: Factor (Indexing | <DOT> CallExpression)? ;

CallExpression #void: LengthCall | MethodCall;

LengthCall: <LENGTH>;

MethodCall: Identifier <OPEN_PAREN> (Expression (<COMMA> Expression)*)? <CLOSE_PAREN> ;

Factor #void: <INTEGER> | <TRUE> | <FALSE> | <THIS> |
        <NOT> Factor |
        <NEW> NewExpression |
        <OPEN_PAREN> AndExpression <CLOSE_PAREN> |
        Identifier ;

NewExpression #void: NewIntArray | NewObject ;

NewIntArray: <INT> <OPEN_SQUARE> Expression <CLOSE_SQUARE> ;

NewObject: Identifier <OPEN_PAREN> <CLOSE_PAREN>;

Identifier:  <IDENT> ({jjtThis.put("name", lastConsumedToken.getImage()); }) ;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}